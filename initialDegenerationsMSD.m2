needsPackage "Polyhedra"
needsPackage "Matroids"
needsPackage "Graphs"


d3n6 = subsets(6,3);
n6 = allMatroids 6;
simpled3n6 = for i in (0..#n6-1) list (if isSimple(n6#i) and rank(n6#i) == 3 then n6#i else continue);


d3n7 = subsets(7,3);
n7 = allMatroids 7;
simpled3n7 = for i in (0..#n7-1) list (if isSimple(n7#i) and rank(n7#i) == 3 then n7#i else continue);



stepwiseSaturate = (I,g) -> (
    for i from 0 to #g-1 do (
        I=saturate(I,sub(g#i, ring I), Strategy=>Bayer);
	);
    return I
    )
-- I is an ideal of a polynomial ring.
-- g is a list of homogeneous elements of ring I.
-- returns the saturation of I with respect to the elements in g.


stepwiseSaturateNoBayer = (I,g) -> (
    for i from 0 to #g-1 do (
        I=saturate(I,sub(g#i, ring I));
        );
    return I
    )
-- I is an ideal of a polynomial ring.
-- g is a list of homogeneous elements of ring I.
-- returns the saturation of I with respect to the elements in g.

GrGfan = (d,n) -> (
    nCd := subsets(n,d);
    Gr := Grassmannian(d-1,n-1,CoefficientRing=>QQ);
    RGrGfan := QQ[apply(nCd, l->value("p"|l#0|l#1|l#2))];
    gfanConversion := map(RGrGfan,ring Gr, matrix{for l from 0 to #nCd-1 list (gens RGrGfan)#l});
    gfanConversion(Gr)    
    )


TSC = S -> (
    d := rank(S);
    n := #(S.groundSet);
    Gr := GrGfan(d,n);
    output := Gr; 
    if #nonbases(S) != 0 then (
	pBases := (bases(S) / (l-> sort toList l)) / (l -> sub(value("p"|l#0|l#1|l#2), ring Gr));
	pNonBases := (nonbases(S) / (l -> sort toList l)) / (l -> sub(value("p"|l#0|l#1|l#2), ring Gr));
    	GrM := eliminate(Gr + ideal(pNonBases), pNonBases);
    	output = sub(stepwiseSaturate(GrM,pBases), QQ[pBases]); 
	);
    return output
    )
-- given a rank 3 matroid S, this computes the ideal of Gr_S in QQ[pijk^{pm}] (note that 
-- we saturate with respect to the pijk.)


TSCpreSaturate = S -> (
    d := rank(S);
    n := #(S.groundSet);
    Gr := GrGfan(d,n);
    output := Gr; 
    if #nonbases(S) != 0 then (
	pBases := (bases(S) / (l-> sort toList l)) / (l -> sub(value("p"|l#0|l#1|l#2), ring Gr));
	pNonBases := (nonbases(S) / (l -> sort toList l)) / (l -> sub(value("p"|l#0|l#1|l#2), ring Gr));
   	output = eliminate(Gr + ideal(pNonBases), pNonBases);
	);
    return output
    )
-- given a rank 3 matroid S, this computes the ideal of Gr_S in QQ[pijk] before inverting the
-- pijk corresponding to bases of S. (note that we do not saturate with respect to the pijk.)




inw=(w,I)->(
    R := ring I;
    Rw := newRing(R, Weights=>w, Global => false);
    inwI := sub(ideal(leadTerm(1, sub(I,Rw))),R);
    return stepwiseSaturate(inwI, gens R)
    )
--w is the vector in TGr_S, in the min convention, revLex ordered.
--I is the ideal of the thin Schubert cell, e.g. TSC(S).



limitTSC = (ringS, SD) -> (
    idealsPreSat := SD / (Si -> TSCpreSaturate(Si));
    idealsPreSat = idealsPreSat / (I -> sub(I,ringS));
    idealPreSat := sum idealsPreSat;
    return stepwiseSaturate(idealPreSat, gens ringS)
    )




makeInitialFormsInFile = (R,M,w) -> (  
    foutName := temporaryFileName () | ".txt";
    fout := openOut(foutName);
    fout << substring(toString(R), 1, #(toString(R)) -1) << endl;
    fout << toString(M) << endl; 
    if #w > 1 then (
	fout << toString(toSequence(w)) << endl; 
	) else (
	fout << "("|toString(w#0)|")";
	);
    close fout;
    return foutName
    )
-- Input: R a ring, M a list of elements of R, w a list of length (gens R).
-- Output: makes temporary file to compute the initial ideal generated by M wrt w using gfan_initialforms. Uses max convention. Returns the name of the file.


makeTropicalStartingConeFile = (R,M) -> (
    foutName := temporaryFileName () | ".txt";
    fout := openOut(foutName); 
    fout << substring(toString(R), 1, #(toString(R)) -1) << endl;
    fout << toString(M) << endl; 
    close fout;
    return foutName
    )
-- Input: R a ring, M a list of elements of R generating  a prime ideal.
-- Output: makes temporary file to compute starting cone using gfan_tropicalstartingcone. Returns name of file. 

    
makeTropicalTraverseFile = (startFile, sym, signs) -> (
    fout := openOutAppend(startFile); 
    fout << toString(sym) << endl;
    fout << toString(signs) << endl;
    close fout;
    return startFile
    )
-- Input: startFile a file to use for gfan_tropicaltraverse, sym a list of symmetries of ideal, signs a list of signs of the symmetries, see gfan documentation. 
-- Output: makes temporary file to compute tropicalization using gfan_tropicaltraverse. Returns name of file. 


makeGroebnerConeFile = (R,M,w) -> (
    inFormsFile := makeInitialFormsInFile(R,M,w); 
    outInFormsFile :=  temporaryFileName () | ".txt";
    grobConeFile := temporaryFileName () | ".txt"; 
    run ("gfan_initialforms --ideal --pair < "|inFormsFile|" > "|outInFormsFile);
    run ("gfan_groebnercone --pair --asfan < "|outInFormsFile|" > "|grobConeFile);
    return grobConeFile
    )

gfanRay = (r,lr) -> (
    tr := separate(" ", r);
    for i in (0..lr-1) list value(tr#i)
    )
-- Input: r a string coming from gfan_tropicaltraverse output representing a RAY, lr an integer representing the ambient dimension of r. 
-- Output: a list of integers representing the ray r.


gfanRaysToM2 = (rs, lr) -> for i from 0 to #rs-1 list gfanRay(rs#i, lr)
-- Input: rs a list of strings r as in gfanRay, lr an integer representing the ambient dimension of each r.
-- Output: a list of lists of integers, representing the rays of the tropicalization. 

gfanLinealityToM2 = (ls, d) -> (
    tls := for i from 0 to #ls-1 list separate(" ", ls#i);
    for i from 0 to #ls-1 list( for j from 0 to d-1 list value(tls#i#j)  )
    )


gfanConeLineToList = l -> (
    Cstr := (separate("#", l))#0;
    rightBracket := position(characters Cstr, i->i== "}");
    CstrNoBrackets := substring(Cstr, 1, rightBracket-1);
    if #CstrNoBrackets == 0 then return {} else return apply(separate(" ", CstrNoBrackets), i->value(i))
    )

parseTropFile = f -> (
     lf := lines get f;
     T := new MutableHashTable;
     
     ambDimLoc := position(lf, i-> i == "AMBIENT_DIM");
     dimLoc := position(lf, i-> i == "DIM");
     nRaysLoc := position(lf, i-> i == "N_RAYS");
     linDimLoc := position(lf, i-> i == "LINEALITY_DIM");
     
     T#"ambDim" = value(lf#(ambDimLoc+1));
     T#"dim" = value(lf#(dimLoc+1));
     T#"linealityDim" = value(lf#(linDimLoc+1));
     T#"nRays" = value(lf#(nRaysLoc+1));
    
     
     if T#"nRays"==0 then T#"rays" = {} else (
	 
         raysLoc := position(lf, i-> i== "RAYS");
 	 conesLoc := position(lf, i-> i=="CONES_ORBITS");
     	 maxConesLoc := position(lf, i-> i=="MAXIMAL_CONES_ORBITS");
    	 multLoc := position(lf, i-> i == "MULTIPLICITIES_ORBITS");
	 conesLines := for i in (conesLoc+1..maxConesLoc-2) list lf#i;
         maxConesLines := for i in (maxConesLoc+1..multLoc-2) list lf#i;
	 
         T#"rays" = gfanRaysToM2(for i from raysLoc+1 to raysLoc+T#"nRays" list lf#i, T#"ambDim");
	 T#"conesOrbits" = for i in (0..#conesLines-1) list gfanConeLineToList(conesLines#i);
         T#"relativeInteriorVectors" = for i in (1..#(T#"conesOrbits")-1) list sum(for j in T#"conesOrbits"#i list T#"rays"#j);    
	 T#"maximalConesOrbits" = for i in (0..#maxConesLines-1) list gfanConeLineToList(maxConesLines#i);
	 );
     
     if T#"linealityDim" == 0 then T#"lineality" = {} else (
	 linLoc := position(lf, i-> i=="LINEALITY_SPACE"); 
	 T#"lineality" = gfanLinealityToM2(for i from linLoc+1 to linLoc+T#"linealityDim" list lf#i, T#"ambDim");
	 ); 
     
     return T
    )

-- Input: file f, the output of gfan_tropicaltraverse
-- Output: a MutableHashTable T:
--    T#"ambDim" = integer, the ambient dimension of the tropicalization
--    T#"dim" = integer, the dimension of the tropicalization
--    T#"linealityDim" = integer, dimension of the lineality space
--    T#"nRays" = integer, number of rays
--    T#"rays" = list of lists of integers, the rays of the tropicalization
--    T#"conesOrbits" = list of lists of integers,  the cones of the tropicalization (as lists of indices of rays)
--    T#"relativeInteriorVectors" = list of lists of integers, the sum of all rays of a given cone, this is a vector in the relative interior of the cone. 
--    T#"lineality" = list of lists of integers, span of these vectors form the lineality space. 
 


tropicalize = (GrS, sym, signs) -> (
    inFileName := makeTropicalStartingConeFile(ring GrS, GrS_*); 
    outFileName := temporaryFileName () | ".txt"; 
    tropFileName :=  temporaryFileName () | ".txt"; 
    run ("gfan_tropicalstartingcone < "|inFileName|" > "|outFileName);
    makeTropicalTraverseFile(outFileName, sym, signs);
    run ("gfan_tropicaltraverse --symmetry --symsigns --nocones < "|outFileName|" > "|tropFileName);
    T := parseTropFile(tropFileName);
    return T
    )
-- Input: GrS an ideal of a thin schubert cell (should be prime), sym list of sequences, signs list of sequences. These are for --symmetry and --symsigns for gfan_tropicaltraverse.
-- Output: a MutableHashTable from parseTropFile

tropicalizeWithVector = (S, w, sym, signs) -> (
    GrS := TSC(S);
    inFileName := makeInitialFormsInFile(ring GrS, GrS_*, w);
    outFileName := temporaryFileName () | ".txt";
    tropFileName :=  temporaryFileName () | ".txt";
    run ("gfan_initialforms --ideal --pair < "|inFileName|" > "|outFileName);
    makeTropicalTraverseFile(outFileName, sym, signs);
    run ("gfan_tropicaltraverse --symmetry --symsigns --nocones< "|outFileName|" > "|tropFileName);
    T := parseTropFile(tropFileName);
    return T
    )
-- Input: GrS an ideal of a thin schubert cell (should be prime), w a list of integers (should be in the relative interior of a maximal cone), sym list of sequences, signs list of sequences. These are for --symmetry and --symsigns for gfan_tropicaltraverse.
-- Output: a MutableHashTable from parseTropFile


----- matroid subdivisions 


basisToPolymakeVector = (b,n) -> (
    str := toString({1}|for i in (0..n-1) list (if any(toList b, x-> x ==  i) then 1 else 0));
    return ("["|substring(str, 1, #str-2)|"]")
    )
    
makePolyFile = (S,w) -> (
    B := bases(S);
    n := #(S.groundSet);
    polyFileName := temporaryFileName () | ".poly";
    f := openOut(polyFileName);
    f << "use application 'polytope';" << endl; 
    f << ("my $w = -new Vector<Rational>(["|substring(toString(w), 1, #(toString(w))-2) |"]);") << endl; 
    f << ("my $p = new Polytope(POINTS => ["|demark(", ", for i in (0..#B-1) list basisToPolymakeVector(B#i,n))|"]);") << endl;
    f << "my $msd = regular_subdivision($p->VERTICES, $w);" << endl; 
    f << "print $msd;";
    close f;
    return polyFileName
    )

matroidSubdivision =  (S,w) -> (
    d := rank(S);
    n := #(S.groundSet);
    f := makePolyFile(S,w);    
    o := temporaryFileName () | ".txt";
    run ("polymake --script "|f|">"|o);
    msdStrs := lines get o;	
    msdIndices := for i in (0..#msdStrs-1) list ( apply(separate(" ", substring(msdStrs#i, 1, #(msdStrs#i)-2)), x->value(x)));
    basesS :=  bases(S) / ( x-> sort toList x); 
    msdBases := for i in (0..#msdIndices-1) list (for j in msdIndices#i list basesS#j);
    return for i in (0..#msdBases-1) list matroid(toList S.groundSet, msdBases#i)
    )



intersectionSets = l -> (
    x := l#0; 
    (0..#l-1) / (i -> x = x * l#i);
    return x
    )
-- Input: l - a list of sets.
-- Output: the intersection of these sets.


commonBasis = SD -> (
    bs := toList intersectionSets(for j in (0..#SD-1) list set bases(SD#j));
    if #bs==0 then return {} else return bs#0
    )
-- Input: SD a list of matroids (should represent the maximal cells of a matroid subidivision of a matroid polytope)
-- Output: a basis common to all matroids in SD, or {} if there is no such basis.


shareEdge = (n, S1, S2) -> (
    bS12 := toList (set bases(S1) * set bases(S2));
    if #bS12 == 0 then return false else (
	S12 := matroid(toList((0..n-1)), bS12);   
	if #(components(S12)) == #(components(S1)) + 1 then return true else return false
        );
    )
-- Input: integer n, matroids S1 and S2 (should represent maximal cells of a matroid subdivision).
-- Output: true if the polytopes of S1 and S2 share a facet, false otherwise.


dualGraph = SD -> (
    n := #((SD#0).groundSet);
    A := matrix( SD/(Si -> SD / (Sj -> if shareEdge(n,Si,Sj) then 1 else 0)) );
    return graph(A) 
    )

adjacencyMatrixSubDivision = SD -> (
    n := #((SD#0).groundSet);
    A := matrix( SD/(Si -> SD / (Sj -> if shareEdge(n,Si,Sj) then 1 else 0)) );
    return A
    )
-- Input: SD a list of matroids (should represent the maximal cells of a matroid subidivision of a matroid polytope)
-- Output: a matrix representing the dual graph to the subdivision SD 




nonLeaves = G ->  for i in vertices(G) list (if isLeaf(G,i) then continue else i)



affineTSC = (S, B, k) -> (
    oB := sort toList B;
    D := new MutableHashTable;
    d := rank(S);
    n := #(S.groundSet);
    xij := for j in (0..n-4) list (for i in (0..d-1) list x_(i,j) );
    R := k[flatten xij]; 
    I := entries id_(R^d); 
    xij = for j in (0..n-4) list (for i in (0..d-1) list sub(x_(i,j), R) ); 
    scan(toList (0..d-1), c-> xij = insert(oB#c, I#c, xij) ); 
    X := transpose matrix xij; 
    D#"ideal" = ideal(0_R);
    basesXij := bases(S) / (b -> det submatrix(X,, toList b));
    nonBasesXij := {}; 
        
    if #(nonbases(S)) != 0 then (
	variablesNonbases := flatten apply (for i in (0..#(nonbases(S))-1) list ( if #(((nonbases(S))#i) * B) == 2 then (nonbases(S))#i else continue), nb -> support det submatrix(X,, toList nb));
	basesXij = unique(apply(basesXij, f  ->  sub(f, variablesNonbases / (g -> g=>0))));
	nonBasesXij = (nonbases(S))/ (nb -> det submatrix(X,, toList nb));
	nonBasesXij = unique(apply(nonBasesXij, f  ->  sub(f, variablesNonbases/ (g -> g=>0 ))) );
	IMpreS := ideal nonBasesXij;
    	D#"ideal" = stepwiseSaturateNoBayer(IMpreS, basesXij);  
        );
    
    D#"ring" = R;
    D#"matrix" = X;
    D#"basesX" = basesXij;
    D#"nonBasesX" = nonBasesXij;
    return D
    )
-- Input: a matroid S, basis B of S, and field k
-- Output: a MutableHashTable D. Say S is a rank d matroid on n elements.  
--    D#"matrix" is a d-by-n matrix whose columns from B form the d-by-d identity matrix, and remaining entries filled in with x_(i,j).
--    D#"ring" = k[x_(i,j)]
--    D#"nonBasesX" = minors of D#"matrix" corresponding to nonbases of S, after setting x_(i,j) corresponding to nonbases = 0.
--    D#"basesX" = minors of D#"matrix" corresponding to bases of S, after setting x_(i,j) corresponding to nonbases = 0.
--    D#"ideal" = ideal generated by D#"nonBasesX" and saturated wrt D#"basesX"
 


affineLimitTSCSubgraph = (S, SD, C, B, k) -> (
    D := new MutableHashTable;
    tscS := affineTSC(S,B,k);
    tscSD :=  (for i in C list SD#i) /(Si ->  affineTSC(Si, B, k)); 
    ideals  := for i in (0..#tscSD-1) list sub(tscSD#i#"ideal", tscS#"ring"); 
    limitIdealPreSat := sum(for i in (0..#tscSD-1) list sub(tscSD#i#"ideal", tscS#"ring"));
    basesSD := unique apply( flatten for i in (0..#tscSD-1) list tscSD#i#"basesX", b -> sub(b,tscS#"ring"));
    
    D#"matrix" = tscS#"matrix"; 
    D#"ring" = tscS#"ring"; 
    D#"idealPreSat" = limitIdealPreSat;
    D#"ideal" = stepwiseSaturateNoBayer(limitIdealPreSat, basesSD);
    D#"basesX" = basesSD;
    D#"tsc" = tscSD;
    D#"graph" = graph(adjacencyMatrixSubDivision(SD));
    D#"ideals" = ideals; 
    D#"singularLocus" = stepwiseSaturateNoBayer(ideal singularLocus(D#"ideal"), apply(D#"basesX", x -> sub(x,D#"ring")) );
    return D
    )
-- Input: a matroid S, a list of matroids SD (representing the maximal cells of a subdivision of S), basis B of S common to all matroids in SD, and field k
-- Output: a MutableHashTable D. Say S is a rank d matroid on n elements.  
--    D#"matrix" is a d-by-n matrix whose columns from B form the d-by-d identity matrix, and remaining entries filled in with x_(i,j).
--    D#"ring" = k[x_(i,j)]
--    D#"tsc" is a list of MutableHashTables affineTSC(Si, B ,k) for Si in SD. 
--    D#"basesX" = list of "basesX" from the elements of D#"tsc".
--    D#"idealPreSat" = ideal of D#"ring", this is the sum of the ideals from D#"tsc".
--    D#"ideal" = D#"idealPreSat" saturated with respect to D#"basesX".
--    D#"graph" = dual graph to the subdivision SD.
--    D#"ideals" = list of the ideals D#"tsc" as ideals of D#"ring".
--    D#"singularLocus" computes the singular locus of  D#"ideal" and saturates with respect to the elements of D#"basesX".



-- Instructions on how to use this program to verify claims in the paper (initial degenerations iso to limits, and in the proof that limits are smooth). 
-- note: requires polymake and gfan. This works with polymake v3.2 and gfan v0.5.

-- -- to compute TGr_0(3,6), set 
-- sym36 = {(0, 1, 3, 2, 4, 6, 5, 8, 7, 9, 10, 12, 11, 14, 13, 15, 17, 16, 18, 19), (3, 6, 8, 9, 12, 14, 15, 17, 18, 19, 0, 1, 2, 4, 5, 7, 10, 11, 13, 16)};
-- signs36 = {(-1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1), (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)};
-- -- and run
-- TGr36 = tropicalize(TSC(simpled3n6#0), sym36, signs36) 
-- -- note that simpled3n6#0 is the uniform matroid.



-- -- to compute TGr_0(3,7), set 
-- w37 = {-1,0,0,0,0,0,0,-1,0,0,0,0,0,0,-1,0,0,0,-1,0,0,0,0,0,0,-1,0,-1,0,0,0,0,0,0,0}, -- this is in the relative interior of a maximal cone of TGr_0(3,7), compare to the first maximal cone in https://www.uni-math.gwdg.de/jensen/Research/G3_7/grassmann3_7.html
-- sym37 = {(0, 1, 3, 2, 4, 6, 5, 8, 7, 9, 10, 12, 11, 14, 13, 15, 17, 16, 18, 19, 20, 22, 21, 24, 23, 25, 27, 26, 28, 29, 31, 30, 32, 33, 34), (3, 6, 8, 9, 12, 14, 15, 17, 18, 19, 22, 24, 25, 27, 28, 29, 31, 32, 33, 34, 0, 1, 2, 4, 5, 7, 10, 11, 13, 16, 20, 21, 23, 26, 30)} 
-- signs37 = {(-1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1), (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)}

-- -- and run
-- TGr37 = tropicalizeWithVector(simpled3n7#0, w37, sym37, signs37) 
-- -- note that simpled3n7#0 is the uniform matroid.

-- -- this takes a while (~1 hour), but the output to gfan is contained in the file TGr37.txt,
-- -- so this can data can be recovered by running  
-- TGr37 = parseTropFile("TGr37.txt")



-- -- To generate all matroid subdivisions, run:

-- MSD36 = new MutableHashTable
-- for i in (0..#(TGr36#"relativeInteriorVectors") - 1 ) do (
--     wi := TGr36#"relativeInteriorVectors"#i;
--     MSD36#wi = matroidSubdivision(simpled3n6#0, wi);
--     )


-- MSD37 = new MutableHashTable
-- for i in (0..#(TGr37#"relativeInteriorVectors") - 1 ) do (
--     wi := TGr37#"relativeInteriorVectors"#i;
--     MSD37#wi = matroidSubdivision(simpled3n7#0, wi);
--     )

-- -- this makes a hashTable, a key is a relative interior point of TGr_0(3,7), 
-- -- and its value is the corresponding matroid subdivision of Delta(3,7).

-- -- Let
-- I36 = TSC(simpled3n6#0) -- this is the ideal of Gr_0(3,6).
-- I37 = TSC(simpled3n7#0) -- this is the ideal of Gr_0(3,7).

-- -- to compute the ideal of, e.g., in_w Gr_0(3,7), run:
-- inw(w, I37)

-- -- Note that this saturates the initial ideal with respect to the product of the variables pijk
-- -- we do this because we think of this as an ideal of k[pijk^{pm}].
-- -- To compute the limit of thin Schubert cells over the subdivision Delta_w, run


-- limitTSC(ring I37, matroidSubdivision(simpled3n7#0, w))

-- -- Note that this saturates the initial ideal with respect to the product of the variables pijk
-- -- we do this because we think of this as an ideal of k[pijk^{pm}].


-- -- for a given w, to show that in_w Gr_0(3,7) == limit_{Delta_w} Gr_M , run
-- inw(w, I37) == limitTSC(ring I37, matroidSubdivision(simpled3n7#0, w)) 
-- -- or since the matroid subdivivisions were already computed, run
-- inw(w, I37) == limitTSC(ring I37, MSD37#w) 


-- -- to check all in_w Gr_0(3,6) == limit_{Delta_w} Gr_M, one could run:
-- all(TGr36#"relativeInteriorVectors", w-> inw(w, I36) == limitTSC(ring I36, MSD36#w))


-- -- to check all in_w Gr_0(3,7) == limit_{Delta_w} Gr_M, one could run:
-- all(TGr37#"relativeInteriorVectors", w-> inw(w, I37) == limitTSC(ring I37, MSD37#w))
-- -- this takes ~2.5 hours.


-- -- For a given w, to show that the limit of thin Schubert cells over the "center" 
-- -- part of a matroid subdivision Delta_w is smooth, set

-- S = simpled3n7#0  -- the uniform matroid
-- SD = MSD37#w -- the madroid subdivision Delta_w precomputed above
-- C = nonLeaves(graph(adjacencyMatrixSubDivision(SD))) -- the indices of the matroids in SD that are not leaves in the dual graph Gamma_w
-- B = commonBasis(for i in C list SD#i) -- a basis common to all matroids in SD whose index is in C

-- -- and run 
-- A = affineLimitTSCSubgraph(S, SD, C, B, QQ)


-- -- this will give a mutableHashTable, call it A. If  A#"singularLocus" == ideal 1,
-- -- then this limit of thin Schubert cells is smooth (note that in computing the singular locus,
-- -- we saturate with respect to each element of A#"basesX" since these elements are viewed as 
-- -- invertible in the ambient ring of the limit.) 


-- -- to check that all are smooth, run

-- smoothTests = {}
-- for i in (0..#(TGr37#"relativeInteriorVectors") - 1) do (
--     w := TGr37#"relativeInteriorVectors"#i;
--     S := simpled3n7#0;
--     SD := MSD37#w;		    
--     C :=  nonLeaves(graph(adjacencyMatrixSubDivision(SD))); 
    
    
--     if #C >0 then (
-- 	B := commonBasis(for j in C list SD#j);
--     	time A := affineLimitTSCSubgraph(S, SD, C, B, QQ); 
--     	smoothTests = append(smoothTests, A#"singularLocus"); 
--     );
-- )

-- all(smoothTests, i->i==ideal(1_(ring i)))

-- -- will return "true"

-- -- note that we ignore the case where there are no leaves in the graph (#C>0 above). In this situation we already prove that
-- -- the limit of thin Schubert cells is smooth in the paper. 

